
@inproceedings{AbbottCategories03,
  title = {Categories of {{Containers}}},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  author = {Abbott, Michael and Altenkirch, Thorsten and Ghani, Neil},
  editor = {Gordon, Andrew D.},
  year = {2003},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {23--38},
  publisher = {{Springer}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/3-540-36576-1_2},
  abstract = {We introduce the notion of containers as a mathematical formalisation of the idea that many important datatypes consist of templates where data is stored. We show that containers have good closure properties under a variety of constructions including the formation of initial algebras and final coalgebras. We also show that containers include strictly positive types and shapely types but that there are containers which do not correspond to either of these. Further, we derive a representation result classifying the nature of polymorphic functions between containers. We finish this paper with an application to the theory of shapely types and refer to a forthcoming paper which applies this theory to differentiable types.},
  isbn = {978-3-540-36576-1},
  langid = {english},
  keywords = {Category theory,Positive types,Shapely types},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\3ZPT2Y86\\Abbott et al. - 2003 - Categories of Containers.pdf}
}

@article{AllaisType18,
  title = {A Type and Scope Safe Universe of Syntaxes with Binding: Their Semantics and Proofs},
  shorttitle = {A Type and Scope Safe Universe of Syntaxes with Binding},
  author = {Allais, Guillaume and Atkey, Robert and Chapman, James and McBride, Conor and McKinna, James},
  year = {2018},
  month = jul,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {2},
  number = {ICFP},
  pages = {90:1--90:30},
  doi = {10.1145/3236785},
  url = {https://doi.org/10.1145/3236785},
  urldate = {2022-01-04},
  abstract = {Almost every programming language's syntax includes a notion of binder and corresponding bound occurrences, along with the accompanying notions of {$\alpha$}-equivalence, capture avoiding substitution, typing contexts, runtime environments, and so on. In the past, implementing and reasoning about programming languages required careful handling to maintain the correct behaviour of bound variables. Modern programming languages include features that enable constraints like scope safety to be expressed in types. Nevertheless, the programmer is still forced to write the same boilerplate over again for each new implementation of a scope safe operation (e.g., renaming, substitution, desugaring, printing, etc.), and then again for correctness proofs. We present an expressive universe of syntaxes with binding and demonstrate how to (1) implement scope safe traversals once and for all by generic programming; and (2) how to derive properties of these traversals by generic proving. Our universe description, generic traversals and proofs, and our examples have all been formalised in Agda and are available in the accompanying material. NB. we recommend printing the paper in colour to benefit from syntax highlighting in code fragments.},
  keywords = {Agda,Fusion,Generic Programming,Logical Relations,Semantics,Simulation,Syntax with Binding},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\KFURT3C7\\Allais et al. - 2018 - A type and scope safe universe of syntaxes with bi.pdf}
}

@inproceedings{AronssonHardware17,
  title = {Hardware Software Co-Design in {{Haskell}}},
  booktitle = {Proceedings of the 10th {{ACM SIGPLAN International Symposium}} on {{Haskell}}},
  author = {Aronsson, Markus and Sheeran, Mary},
  year = {2017},
  month = sep,
  series = {Haskell 2017},
  pages = {162--173},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3122955.3122970},
  url = {https://doi.org/10.1145/3122955.3122970},
  urldate = {2022-01-04},
  abstract = {We present a library in Haskell for programming Field Programmable Gate Arrays (FPGAs), including hardware software co-design. Code for software (in C) and hardware (in VHDL) is generated from a single program, along with the code to support communication between hardware and software. We present type-based techniques for the simultaneous implementation of more than one embedded domain specific language (EDSL). We build upon a generic representation of imperative programs that is loosely coupled to instruction and expression types, allowing the individual parts to be developed and improved separately. Code generation is implemented as a series of translations between progressively smaller, typed EDSLs, safeguarding against errors that arise in untyped translations. Initial case studies show promising performance.},
  isbn = {978-1-4503-5182-9},
  keywords = {Domain-specific languages,Hardware,Hardware software co-design,Monads},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\ELXHT5KG\\Aronsson and Sheeran - 2017 - Hardware software co-design in Haskell.pdf}
}

@article{AtkeyParameterised09,
  title = {Parameterised Notions of Computation},
  author = {Atkey, Robert},
  year = {2009},
  month = jul,
  journal = {Journal of Functional Programming},
  volume = {19},
  number = {3-4},
  pages = {335--376},
  issn = {0956-7968},
  doi = {10.1017/S095679680900728X},
  url = {https://doi.org/10.1017/S095679680900728X},
  urldate = {2022-02-28},
  abstract = {Moggi's Computational Monads and Power et al.'s equivalent notion of Freyd category have captured a large range of computational effects present in programming languages. Examples include non-termination, non-determinism, exceptions, continuations, side effects and input/output. We present generalisations of both computational monads and Freyd categories, which we call parameterised monads and parameterised Freyd categories, that also capture computational effects with parameters. Examples of such are composable continuations, side effects where the type of the state varies and input/output where the range of inputs and outputs varies. By considering structured parameterisation also, we extend the range of effects to cover separated side effects and multiple independent streams of I/O. We also present two typed {$\lambda$}-calculi that soundly and completely model our categorical definitions \textendash{} with and without symmetric monoidal parameterisation \textendash{} and act as prototypical languages with parameterised effects.},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\YXAS2R7L\\Atkey - 2009 - Parameterised notions of computation.pdf}
}

@article{AxelssonWired05,
  title = {Wired: {{Wire-Aware Circuit Design}}},
  shorttitle = {Wired},
  author = {Axelsson, Emil and Claessen, Koen Lindstr{\"o}m and Sheeran, Mary},
  year = {2005},
  journal = {Correct Hardware Design and Verification Methods},
  volume = {3725},
  pages = {5--19},
  url = {https://research.chalmers.se/en/publication/8753},
  urldate = {2022-01-04},
  isbn = {9783540291053},
  langid = {english},
  keywords = {Hardware,Non-standard interpretation,Relational programming},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\2FIXZ4DG\\Axelsson et al. - 2005 - Wired Wire-Aware Circuit Design.pdf}
}

@mastersthesis{BaaijClash09,
  title = {{{C$\lambda$asH}} : From {{Haskell}} to Hardware},
  shorttitle = {{{C$\lambda$asH}}},
  author = {Baaij, C.},
  year = {2009},
  month = dec,
  address = {{Enschede}},
  url = {http://essay.utwente.nl/59482/},
  urldate = {2022-01-04},
  abstract = {Functional hardware description languages are a class of hardware description languages that emphasize on the ability to express higher level structural properties, such a parameterization and regularity. Due to such features as higher-order functions and polymorphism, parameterization in functional hardware description languages is more natural than the parameterization support found in the more traditional hardware description languages, like VHDL and Verilog. We develop a new functional hardware description language, C{$\lambda$}asH, that borrows both the syntax and semantics from the general-purpose functional programming language Haskell. In many existing functional hardware description languages, a circuit designer has to use language primitives that are encoded as data-types and combinators within Haskell. In C{$\lambda$}asH on the other hand, circuit designers build their circuits using regular Haskell syntax. Where many existing languages encode state using a so-called delay element within the body of a function, C{$\lambda$}asH specifications explicitly encode state in the type-signature of a function thereby avoiding the nodesharing problem most other functional hardware description languages face. To cope with the direct physical restrictions of hardware, the familiar dynamically sized lists found in Haskell are replaced with fixed-size vectors. Being in essence a subset of Haskell, C{$\lambda$}asH inherits the strong typing system of Haskell. C{$\lambda$}asH exploits this typing system to specify the dependently-typed fixed-size vectors, be it that the dependent types are `fake'. As the designers of Haskell never set out to create a dependently typed language, the fixed-size vector specification suffers slightly from limits imposed by the typing system. Still, the developed fixed-size vector library presents a myriad of functionality to an eventual circuit designer. Besides having support for fixed-size vectors, C{$\lambda$}asH also incorporates two integer type primitives. C{$\lambda$}asH can be used to develop more than just trivial designs, exemplified by the reduction circuit designed with it. The C{$\lambda$}asH design  f this reduction circuit runs only 50\% slower than a hand-coded optimized VHDL design, even though this first generation C{$\lambda$}asH compiler does not have any optimizations whatsoever. With the used FPGA resources being in the same order as the resources used by the hand-coded VHDL we are confident that this first-generation compiler is indeed well behaved. Much has been accomplished with this first attempt at developing a new functional hardware description language, as it already allows us to build more than just trivial designs. There are however many possibilities for future work, the most pressing being able to support recursive functions.},
  langid = {english},
  school = {University of Twente},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\2Z9YX6EX\\Baaij - 2009 - CλasH  from Haskell to hardware.pdf}
}

@inproceedings{bahrCompositionalDataTypes2011,
  title = {Compositional Data Types},
  booktitle = {Proceedings of the Seventh {{ACM SIGPLAN}} Workshop on {{Generic}} Programming},
  author = {Bahr, Patrick and Hvitved, Tom},
  year = {2011},
  month = sep,
  series = {{{WGP}} '11},
  pages = {83--94},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2036918.2036930},
  url = {https://doi.org/10.1145/2036918.2036930},
  urldate = {2022-02-04},
  abstract = {Building on Wouter Swierstra's Data types \`a la carte, we present a comprehensive Haskell library of compositional data types suitable for practical applications. In this framework, data types and functions on them can be defined in a modular fashion. We extend the existing work by implementing a wide array of recursion schemes including monadic computations. Above all, we generalise recursive data types to contexts, which allow us to characterise a special yet frequent kind of catamorphisms. The thus established notion of term homomorphisms allows for flexible reuse and enables short-cut fusion style deforestation which yields considerable speedups. We demonstrate our framework in the setting of compiler construction, and moreover, we compare compositional data types with generic programming techniques and show that both are comparable in run-time performance and expressivity while our approach allows for stricter types. We substantiate this conclusion by lifting compositional data types to recursive data types and generalised algebraic data types. Lastly, we compare the run-time performance of our techniques with traditional implementations over algebraic data types. The results are surprisingly good.},
  isbn = {978-1-4503-0861-8},
  keywords = {algebraic programming,deforestation,mutual recursion,reusability},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\VPLYJP87\\Bahr and Hvitved - 2011 - Compositional data types.pdf}
}

@article{bahrParametricCompositionalData2012,
  title = {Parametric {{Compositional Data Types}}},
  author = {Bahr, Patrick and Hvitved, Tom},
  year = {2012},
  month = feb,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {76},
  eprint = {1202.2917},
  eprinttype = {arxiv},
  pages = {3--24},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.76.3},
  url = {http://arxiv.org/abs/1202.2917},
  urldate = {2022-02-04},
  abstract = {In previous work we have illustrated the benefits that compositional data types (CDTs) offer for implementing languages and in general for dealing with abstract syntax trees (ASTs). Based on Swierstra's data types \textbackslash 'a la carte, CDTs are implemented as a Haskell library that enables the definition of recursive data types and functions on them in a modular and extendable fashion. Although CDTs provide a powerful tool for analysing and manipulating ASTs, they lack a convenient representation of variable binders. In this paper we remedy this deficiency by combining the framework of CDTs with Chlipala's parametric higher-order abstract syntax (PHOAS). We show how a generalisation from functors to difunctors enables us to capture PHOAS while still maintaining the features of the original implementation of CDTs, in particular its modularity. Unlike previous approaches, we avoid so-called exotic terms without resorting to abstract types: this is crucial when we want to perform transformations on CDTs that inspect the recursively computed CDTs, e.g. constant folding.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\F9WDI5U5\\Bahr and Hvitved - 2012 - Parametric Compositional Data Types.pdf}
}

@article{BradyIdrisQTT21,
  title = {Idris 2: {{Quantitative Type Theory}} in {{Practice}}},
  shorttitle = {Idris 2},
  author = {Brady, Edwin},
  year = {2021},
  month = apr,
  journal = {arXiv:2104.00480 [cs]},
  eprint = {2104.00480},
  eprinttype = {arxiv},
  primaryclass = {cs},
  url = {http://arxiv.org/abs/2104.00480},
  urldate = {2022-02-28},
  abstract = {Dependent types allow us to express precisely what a function is intended to do. Recent work on Quantitative Type Theory (QTT) extends dependent type systems with linearity, also allowing precision in expressing when a function can run. This is promising, because it suggests the ability to design and reason about resource usage protocols, such as we might find in distributed and concurrent programming, where the state of a communication channel changes throughout program execution. As yet, however, there has not been a full-scale programming language with which to experiment with these ideas. Idris 2 is a new version of the dependently typed language Idris, with a new core language based on QTT, supporting linear and dependent types. In this paper, we introduce Idris 2, and describe how QTT has influenced its design. We give examples of the benefits of QTT in practice including: expressing which data is erased at run time, at the type level; and, resource tracking in the type system leading to type-safe concurrent programming with session types.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\8FG9M3VF\\Brady - 2021 - Idris 2 Quantitative Type Theory in Practice.pdf}
}

@inproceedings{BradyProgramming13,
  title = {Programming and Reasoning with Algebraic Effects and Dependent Types},
  booktitle = {Proceedings of the 18th {{ACM SIGPLAN}} International Conference on {{Functional}} Programming},
  author = {Brady, Edwin},
  year = {2013},
  month = sep,
  series = {{{ICFP}} '13},
  pages = {133--144},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2500365.2500581},
  url = {https://doi.org/10.1145/2500365.2500581},
  urldate = {2022-01-04},
  abstract = {One often cited benefit of pure functional programming is that pure code is easier to test and reason about, both formally and informally. However, real programs have side-effects including state management, exceptions and interactions with the outside world. Haskell solves this problem using monads to capture details of possibly side-effecting computations --- it provides monads for capturing state, I/O, exceptions, non-determinism, libraries for practical purposes such as CGI and parsing, and many others, as well as monad transformers for combining multiple effects. Unfortunately, useful as monads are, they do not compose very well. Monad transformers can quickly become unwieldy when there are lots of effects to manage, leading to a temptation in larger programs to combine everything into one coarse-grained state and exception monad. In this paper I describe an alternative approach based on handling algebraic effects, implemented in the IDRIS programming language. I show how to describe side effecting computations, how to write programs which compose multiple fine-grained effects, and how, using dependent types, we can use this approach to reason about states in effectful programs.},
  isbn = {978-1-4503-2326-0},
  keywords = {Algebraic effects,Dependent types},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\BNFEFAMH\\Brady - 2013 - Programming and reasoning with algebraic effects and dependent types.pdf}
}

@inproceedings{BradyResourceSafe12,
  title = {Resource-{{Safe}} Systems Programming with Embedded Domain Specific Languages},
  booktitle = {Proceedings of the 14th International Conference on {{Practical Aspects}} of {{Declarative Languages}}},
  author = {Brady, Edwin and Hammond, Kevin},
  year = {2012},
  month = jan,
  series = {{{PADL}}'12},
  pages = {242--257},
  publisher = {{Springer-Verlag}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-27694-1_18},
  url = {https://doi.org/10.1007/978-3-642-27694-1_18},
  urldate = {2022-01-04},
  abstract = {We introduce a new overloading notation that facilitates programming, modularity and reuse in Embedded Domain Specific Languages (EDSLs), and use it to reason about safe resource usage and state management. We separate the structural language constructs from our primitive operations, and show how precisely-typed functions can be lifted into the EDSL. In this way, we implement a generic framework for constructing state-aware EDSLs for systems programming.},
  isbn = {978-3-642-27693-4},
  keywords = {Dependent types,Domain-specific languages,resource usage,Software verification},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\RB5C3WKM\\Brady and Hammond - 2012 - Resource-Safe systems programming with EDSLs.pdf}
}

@misc{BradyState16,
  title = {State {{Machines All The Way Down}} - {{An Architecture}} for {{Depdendently Typed Applications}}},
  author = {Brady, Edwin},
  year = {2016},
  abstract = {A useful pattern in dependently typed programming is to define a state transition system, for example the states and operations in a network protocol, as an indexed monad. We index each operation by its input and output states, thus guaranteeing that operations satisfy pre- and post-conditions, by typechecking. However, what if we want to write a program using several systems at once? What if we want to define a high level state transition system, such as a network application protocol, in terms of lower level states, such as network sockets and mutable variables? In this paper, we present an architecture for dependently typed applications based on a hierarchy of state transition systems, implemented in a generic data type ST. This is based on a monad indexed by contexts of resources, allowing us to reason about multiple state transition systems in the type of a function. Using ST, we show: how to implement a state transition system as a dependent type, with type level guarantees on its operations; how to account for operations which could fail; how to combine state transition systems into a larger system; and, how to implement larger systems as a hierarchy of state transition systems. We illustrate the system by implementing a number of examples, including a graphics API, POSIX network sockets, asynchronous programming with threads, and a high level network application protocol.},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\PCISB23R\\Brady - 2016 - State Machines All The Way Down.pdf}
}

@inproceedings{BrownAllegories94,
  title = {Categories, Allegories and Circuit Design},
  booktitle = {Proceedings {{Ninth Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Brown, C. and Hutton, G.},
  year = {1994},
  month = jul,
  pages = {372--381},
  doi = {10.1109/LICS.1994.316052},
  abstract = {Relational languages such as RUBY are used to derive hardware circuits from abstract specifications of their behaviour. Much reasoning is done informally in RUBY using pictorial representations of relational terms. We formalise this use of pictures in circuit design. We show that pictures naturally form a unitary pretabular allegory. Homomorphisms of pictures correspond to adding new wires or circuit comments. Two pictures are mutually homomorphic if and only if they represent equal allegorical terms. We prove soundness and completeness results which guarantee that deriving circuits using pictures does not lead to errors. We illustrate the use of pictures by deriving the ripple adder implementation from a high level, behavioural specification.{$<>$}},
  keywords = {Allegory,Category theory,Hardware,Ruby},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\UPA5I7RD\\Brown and Hutton - 1994 - Categories, allegories and circuit design.pdf}
}

@inproceedings{ChristiansenElabReflection16,
  title = {Elaborator Reflection: Extending {{Idris}} in {{Idris}}},
  shorttitle = {Elaborator Reflection},
  booktitle = {Proceedings of the 21st {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  author = {Christiansen, David and Brady, Edwin},
  year = {2016},
  month = sep,
  series = {{{ICFP}} 2016},
  pages = {284--297},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2951913.2951932},
  url = {https://doi.org/10.1145/2951913.2951932},
  urldate = {2022-02-28},
  abstract = {Many programming languages and proof assistants are defined by elaboration from a high-level language with a great deal of implicit information to a highly explicit core language. In many advanced languages, these elaboration facilities contain powerful tools for program construction, but these tools are rarely designed to be repurposed by users. We describe elaborator reflection, a paradigm for metaprogramming in which the elaboration machinery is made directly available to metaprograms, as well as a concrete realization of elaborator reflection in Idris, a functional language with full dependent types. We demonstrate the applicability of Idris's reflected elaboration framework to a number of realistic problems, we discuss the motivation for the specific features of its design, and we explore the broader meaning of elaborator reflection as it can relate to other languages.},
  isbn = {978-1-4503-4219-3},
  keywords = {dependent types,elaboration,Metaprogramming},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\QLABY2WI\\Christiansen and Brady - 2016 - Elaborator reflection extending Idris in Idris.pdf}
}

@article{ElliottCompiling17,
  title = {Compiling to Categories},
  author = {Elliott, Conal},
  year = {2017},
  month = aug,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {1},
  number = {ICFP},
  pages = {27:1--27:27},
  doi = {10.1145/3110271},
  url = {https://doi.org/10.1145/3110271},
  urldate = {2022-01-04},
  abstract = {It is well-known that the simply typed lambda-calculus is modeled by any cartesian closed category (CCC). This correspondence suggests giving typed functional programs a variety of interpretations, each corresponding to a different category. A convenient way to realize this idea is as a collection of meaning-preserving transformations added to an existing compiler, such as GHC for Haskell. This paper describes such an implementation and demonstrates its use for a variety of interpretations including hardware circuits, automatic differentiation, incremental computation, and interval analysis. Each such interpretation is a category easily defined in Haskell (outside of the compiler). The general technique appears to provide a compelling alternative to deeply embedded domain-specific languages.},
  keywords = {Category theory,Domain-specific languages,Hardware},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\W92PYWWN\\Elliott - 2017 - Compiling to categories.pdf}
}

@article{evansCircuitFlowDomainSpecific2021,
  title = {{{CircuitFlow}}: {{A Domain Specific Language}} for {{Dataflow Programming}}},
  shorttitle = {{{CircuitFlow}}},
  author = {Evans, Riley and Frohlich, Samantha and Wang, Meng},
  year = {2021},
  month = nov,
  journal = {arXiv:2111.12420 [cs]},
  eprint = {2111.12420},
  eprinttype = {arxiv},
  primaryclass = {cs},
  url = {http://arxiv.org/abs/2111.12420},
  urldate = {2022-02-04},
  abstract = {Dataflow applications, such as machine learning algorithms, can run for days, making it desirable to have assurances that they will work correctly. Current tools are not good enough: too often the interactions between tasks are not type-safe, leading to undesirable run-time errors. This paper presents a new declarative Haskell Embedded DSL (eDSL) for dataflow programming: CircuitFlow. Defined as a Symmetric Monoidal Preorder (SMP) on data that models dependencies in the workflow, it has a strong mathematical basis, refocusing on how data flows through an application, resulting in a more expressive solution that not only catches errors statically, but also achieves competitive run-time performance. In our preliminary evaluation, CircuitFlow outperforms the industry-leading Luigi library of Spotify by scaling better with the number of inputs. The innovative creation of CircuitFlow is also of note, exemplifying how to create a modular eDSL whose semantics necessitates effects, and where storing complex type information for program correctness is paramount.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\DJA6XJHU\\Evans et al. - 2021 - CircuitFlow A Domain Specific Language for Dataflow Programming.pdf}
}

@article{fioreFormalMetatheorySecondorder2022,
  title = {Formal Metatheory of Second-Order Abstract Syntax},
  author = {Fiore, Marcelo and Szamozvancev, Dmitrij},
  year = {2022},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {6},
  number = {POPL},
  pages = {53:1--53:29},
  doi = {10.1145/3498715},
  url = {https://doi.org/10.1145/3498715},
  urldate = {2022-02-04},
  abstract = {Despite extensive research both on the theoretical and practical fronts, formalising, reasoning about, and implementing languages with variable binding is still a daunting endeavour \textendash{} repetitive boilerplate and the overly complicated metatheory of capture-avoiding substitution often get in the way of progressing on to the actually interesting properties of a language. Existing developments offer some relief, however at the expense of inconvenient and error-prone term encodings and lack of formal foundations. We present a mathematically-inspired language-formalisation framework implemented in Agda. The system translates the description of a syntax signature with variable-binding operators into an intrinsically-encoded, inductive data type equipped with syntactic operations such as weakening and substitution, along with their correctness properties. The generated metatheory further incorporates metavariables and their associated operation of metasubstitution, which enables second-order equational/rewriting reasoning. The underlying mathematical foundation of the framework \textendash{} initial algebra semantics \textendash{} derives compositional interpretations of languages into their models satisfying the semantic substitution lemma by construction.},
  keywords = {abstract syntax,Agda,category theory,language formalisation},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\FMSP8QVF\\Fiore and Szamozvancev - 2022 - Formal metatheory of second-order abstract syntax.pdf}
}

@article{FokkingaTransformers96,
  title = {{Datatype Laws Without Signatures}},
  author = {Fokkinga, M. M.},
  year = {1996},
  month = feb,
  journal = {Mathematical structures in computer science},
  volume = {6},
  number = {1},
  pages = {1--32},
  publisher = {{Cambridge University Press}},
  issn = {0960-1295},
  doi = {10.1017/S0960129500000852},
  url = {https://research.utwente.nl/en/publications/datatype-laws-without-signatures},
  urldate = {2022-01-04},
  abstract = {Using the well-known categorical notion of `functor' one may define the concept of datatype (algebra) without being forced to introduce a signature, that is, names and typings for the individual sorts (types) and operations involved. This has proved to be advantageous for those theory developments where one is not interested in the syntactic appearance of an algebra. The categorical notion of `transformer' developed in this paper allows the same approach to laws: without using signatures one can define the concept of law for datatypes (lawful algebras), and investigate the equational specification of datatypes in a syntax-free way. A transformer is a special kind of functor and also a natural transformation on the level of dialgebras. Transformers are quite expressive, satisfy several closure properties, and are related to naturality and Wadler's Theorems For Free. In fact, any colimit is an initial lawful algebra.},
  langid = {Undefined},
  keywords = {Algebraic effects,Category theory},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\6M6T3K26\\Fokkinga - 1996 - Datatype Laws Without Signatures.pdf}
}

@inproceedings{GuoCompilingRuby95,
  title = {Compiling {{Ruby}} into {{FPGAs}}},
  booktitle = {Proceedings of the 5th {{International Workshop}} on {{Field-Programmable Logic}} and {{Applications}}},
  author = {Guo, Shaori and Luk, Wayne},
  year = {1995},
  month = sep,
  series = {{{FPL}} '95},
  pages = {188--197},
  publisher = {{Springer-Verlag}},
  address = {{Berlin, Heidelberg}},
  abstract = {This paper presents an overview of a prototype hardware compiler which compiles a design expressed in the Ruby language into FPGAs. The features of two important modules, the refinement module and the floorplanning module, are discussed and illustrated. Target code can be produced in various formats, including device-specific formats such as XNF or CFG, and device-independent formats such as VHDL. The viability of our floorplanning scheme is demonstrated by a compiler backend for Algotronix's CAL1024 FPGAs. The implementation of a priority queue is used to illustrate our approach.},
  isbn = {978-3-540-60294-1},
  keywords = {FPGA,Hardware,Ruby},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\8VQMJCMT\\Guo and Luk - 1995 - Compiling Ruby into FPGAs.pdf}
}

@article{HillerstromEffect20,
  title = {Effect Handlers via Generalised Continuations},
  author = {Hillerstr{\"o}m, Daniel and Lindley, Sam and Atkey, Robert},
  year = {2020/ed},
  journal = {Journal of Functional Programming},
  volume = {30},
  publisher = {{Cambridge University Press}},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796820000040},
  url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/effect-handlers-via-generalised-continuations/DF590482FEE2F6888CD68B4B446E31D5#},
  urldate = {2022-01-04},
  abstract = {Plotkin and Pretnar's effect handlers offer a versatile abstraction for modular programming with user-defined effects. This paper focuses on foundations for implementing effect handlers, for the three different kinds of effect handlers that have been proposed in the literature: deep, shallow, and parameterised. Traditional deep handlers are defined by folds over computation trees and are the original construct proposed by Plotkin and Pretnar. Shallow handlers are defined by case splits (rather than folds) over computation trees. Parameterised handlers are deep handlers extended with a state value that is threaded through the folds over computation trees. We formulate the extensions both directly and via encodings in terms of deep handlers and illustrate how the direct implementations avoid the generation of unnecessary closures. We give two distinct foundational implementations of all the kinds of handlers we consider: a continuation-passing style (CPS) transformation and a CEK-style abstract machine. In both cases, the key ingredient is a generalisation of the notion of continuation to accommodate stacks of effect handlers. We obtain our CPS translation through a series of refinements as follows. We begin with a first-order CPS translation into untyped lambda calculus which manages a stack of continuations and handlers as a curried sequence of arguments. We then refine the initial CPS translation by uncurrying it to yield a properly tail-recursive translation and then moving towards more and more intensional representations of continuations in order to support different kinds of effect handlers. Finally, we make the translation higher order in order to contract administrative redexes at translation time. Our abstract machine design then uses the same generalised continuation representation as the CPS translation. We have implemented both the abstract machine and the CPS transformation (plus extensions) as backends for the Links web programming language.},
  langid = {english},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\FXXBFINN\\Hillerström et al. - 2020 - Effect handlers via generalised continuations.pdf}
}

@inproceedings{HinzeTypeIndexed02,
  title = {Type-{{Indexed Data Types}}},
  booktitle = {Proceedings of the 6th {{International Conference}} on {{Mathematics}} of {{Program Construction}}},
  author = {Hinze, Ralf and Jeuring, Johan and L{\"o}h, Andres},
  year = {2002},
  month = jul,
  series = {{{MPC}} '02},
  pages = {148--174},
  publisher = {{Springer-Verlag}},
  address = {{Berlin, Heidelberg}},
  abstract = {A polytypic function is a function that can be instantiated on many data types to obtain data type specific functionality. Examples of polytypic functions are the functions that can be derived in Haskell, such as show, read, and '=='. More advanced examples are functions for digital searching, pattern matching, unification, rewriting, and structure editing. For each of these problems, we not only have to define polytypic functionality, but also a type-indexed data type: a data type that is constructed in a generic way from an argument data type. For example, in the case of digital searching we have to define a search tree type by induction on the structure of the type of search keys. This paper shows how to define type-indexed data types, discusses several examples of type-indexed data types, and shows how to specialize type-indexed data types. The approach has been implemented in Generic Haskell, a generic programming extension of the functional language Haskell.},
  isbn = {978-3-540-43857-1},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\LFNUS5QW\\Hinze et al. - 2002 - Type-Indexed Data Types.pdf}
}

@article{hookerHardwareLottery2020,
  title = {The {{Hardware Lottery}}},
  author = {Hooker, Sara},
  year = {2020},
  month = sep,
  journal = {arXiv:2009.06489 [cs]},
  eprint = {2009.06489},
  eprinttype = {arxiv},
  primaryclass = {cs},
  url = {http://arxiv.org/abs/2009.06489},
  urldate = {2022-01-07},
  abstract = {Hardware, systems and algorithms research communities have historically had different incentive structures and fluctuating motivation to engage with each other explicitly. This historical treatment is odd given that hardware and software have frequently determined which research ideas succeed (and fail). This essay introduces the term hardware lottery to describe when a research idea wins because it is suited to the available software and hardware and not because the idea is superior to alternative research directions. Examples from early computer science history illustrate how hardware lotteries can delay research progress by casting successful ideas as failures. These lessons are particularly salient given the advent of domain specialized hardware which make it increasingly costly to stray off of the beaten path of research ideas. This essay posits that the gains from progress in computing are likely to become even more uneven, with certain research directions moving into the fast-lane while progress on others is further obstructed.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Computers and Society,Computer Science - Hardware Architecture,Computer Science - Machine Learning},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\W5BKIBRW\\Hooker - 2020 - The Hardware Lottery.pdf}
}

@techreport{HuttonPers92,
  title = {A {{Calculational Theory}} of {{Pers}} as {{Types}}},
  author = {Hutton, Graham and Voermans, Ed},
  year = {1992},
  month = jan,
  institution = {{University of Glasgow}},
  url = {http://www.cs.nott.ac.uk/~pszgmh/bib.html#pers},
  abstract = {In the calculational approach to programming, programs are derived from specifications by algebraic reasoning. This report presents a calculational programming framework based upon the notion of binary relations as programs, and partial equivalence relations (pers) as types. Working with relations as programs generalises the functional paradigm, admiting non-determinism and the use of relation converse. Working with pers as types permits a natural treatment of types that are subject to laws and restrictions.},
  keywords = {Data types,Lattice theory,Relational programming,Ruby,Type theory},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\QZVXLDGJ\\Hutton and Voermans - 1992 - A Calculational Theory of Pers as Types.pdf}
}

@inproceedings{HuttonRelations99,
  title = {Functional {{Programming With Relations}}},
  booktitle = {Proceedings of the 1990 {{Glasgow Workshop}} on {{Functional Programming}}},
  author = {Hutton, Graham},
  year = {1999},
  month = sep,
  series = {Springer-{{Verlag Series}} of {{Workshops}} in {{Computing}}},
  publisher = {{Springer}},
  address = {{Ullapool, Scotland}},
  doi = {10.1007/978-1-4471-3810-5_11},
  url = {http://www.cs.nott.ac.uk/~pszgmh/bib.html#causal},
  abstract = {While programming in a relational framework has much to offer over the functional style in terms of expressiveness, computing with relations is less efficient, and more semantically troublesome. In this paper we propose a novel blend of the functional and relational styles. We identify a class of causal relations , which inherit some of the bi--directionality properties of relations, but retain the efficiency and semantic foundations of the functional style. 1 Introduction In his ACM Turing Award Lecture, Backus presented a new style of programming, in which programs are built piecewise by combining smaller programs [Backus78]. In [Sheeran83], Sheeran showed how the same approach could be used to good effect in VLSI design. In keeping with the special constraints of hardware, many designs have a regular structure, with components communicating, often bi--directionally, only with their immediate neighbours. With function composition as the main combining form however, circuits wi...},
  keywords = {Data types,Lattice theory,Relational programming,Ruby,Type theory},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\26PYKEZ2\\Hutton - 1999 - Functional Programming With Relations.pdf}
}

@phdthesis{HuttonThesis92,
  title = {Between {{Functions}} and {{Relations}} in {{Calculating Programs}}},
  author = {Hutton, Graham Muir},
  year = {1992},
  address = {{Glasgow}},
  issn = {1099-2278},
  url = {https://theses.gla.ac.uk/74656/},
  urldate = {2022-01-04},
  abstract = {This thesis is about the calculational approach to programming, in which one derives programs from specifications. One such calculational paradigm is Ruby, the relational calculus developed by Jones and Sheeran for describing and designing circuits. We identify two shortcomings with derivations made using Ruby. The first is that the notion of a program being an implementation of a specification has never been made precise. The second is to do with types. Fundamental to the use of type information in deriving programs is the idea of having types as special kinds of programs. In Ruby, types are partial equivalence relations (pers). Unfortunately, manipulating some formulae involving types has proved difficult within Ruby. In particular, the preconditions of the 'induction' laws that are much used within program derivation often work out to be assertions about types; such assertions have typically been verified either by informal arguments or by using predicate calculus, rather than by applying algebraic laws from Ruby. In this thesis we address both of the shortcomings noted above. We define what it means for a Ruby program to be an implementation, by introducing the notion of a causal relation, and the network denoted by a Ruby program. A relation is causal if it is functional in some structural way, but not necessarily from domain to range; a network captures the connectivity between the primitive relations in a program. Moreover, we present an interpreter for Ruby programs that are implementations. Our technique for verifying an assertion about types is to first express it using operators that give the best left and right types for a relation, and then verify this assertion by using algebraic properties of these operators.},
  langid = {english},
  school = {University of Glasgow},
  keywords = {Lattice theory,Relational programming,Ruby,Type theory},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\K52553GQ\\Hutton - 1992 - Between Functions and Relations in Calculating Programs.pdf}
}

@article{KidneyAlgebras21,
  title = {Algebras for Weighted Search},
  author = {Kidney, Donnacha Ois{\'i}n and Wu, Nicolas},
  year = {2021},
  month = aug,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {5},
  number = {ICFP},
  pages = {72:1--72:30},
  doi = {10.1145/3473577},
  url = {https://doi.org/10.1145/3473577},
  urldate = {2022-01-04},
  abstract = {Weighted search is an essential component of many fundamental and useful algorithms. Despite this, it is relatively under explored as a computational effect, receiving not nearly as much attention as either depth- or breadth-first search. This paper explores the algebraic underpinning of weighted search, and demonstrates how to implement it as a monad transformer. The development first explores breadth-first search, which can be expressed as a polynomial over semirings. These polynomials are generalised to the free semimodule monad to capture a wide range of applications, including probability monads, polynomial monads, and monads for weighted search. Finally, a monad transformer based on the free semimodule monad is introduced. Applying optimisations to this type yields an implementation of pairing heaps, which is then used to implement Dijkstra's algorithm and efficient probabilistic sampling. The construction is formalised in Cubical Agda and implemented in Haskell.},
  keywords = {Agda,graph search,Monads},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\KAPYHNUL\\Kidney and Wu - 2021 - Algebras for weighted search.pdf}
}

@inproceedings{KiselyovFreer15,
  title = {Freer Monads, More Extensible Effects},
  booktitle = {Proceedings of the 2015 {{ACM SIGPLAN Symposium}} on {{Haskell}}},
  author = {Kiselyov, Oleg and Ishii, Hiromi},
  year = {2015},
  month = aug,
  series = {Haskell '15},
  pages = {94--105},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2804302.2804319},
  url = {https://doi.org/10.1145/2804302.2804319},
  urldate = {2022-01-04},
  abstract = {We present a rational reconstruction of extensible effects, the recently proposed alternative to monad transformers, as the confluence of efforts to make effectful computations compose. Free monads and then extensible effects emerge from the straightforward term representation of an effectful computation, as more and more boilerplate is abstracted away. The generalization process further leads to freer monads, constructed without the Functor constraint. The continuation exposed in freer monads can then be represented as an efficient type-aligned data structure. The end result is the algorithmically efficient extensible effects library, which is not only more comprehensible but also faster than earlier implementations. As an illustration of the new library, we show three surprisingly simple applications: non-determinism with committed choice (LogicT), catching IO exceptions in the presence of other effects, and the semi-automatic management of file handles and other resources through monadic regions. We extensively use and promote the new sort of `laziness', which underlies the left Kan extension: instead of performing an operation, keep its operands and pretend it is done.},
  isbn = {978-1-4503-3808-0},
  keywords = {coroutine,Effect handlers,effect interaction,Kan extension,Monads,open union,type and effect system},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\6QZIADMJ\\Kiselyov and Ishii - 2015 - Freer monads, more extensible effects.pdf}
}

@inproceedings{LindleyHasochism13,
  title = {Hasochism: The Pleasure and Pain of Dependently Typed Haskell Programming},
  shorttitle = {Hasochism},
  booktitle = {Proceedings of the 2013 {{ACM SIGPLAN}} Symposium on {{Haskell}}},
  author = {Lindley, Sam and McBride, Conor},
  year = {2013},
  month = sep,
  series = {Haskell '13},
  pages = {81--92},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2503778.2503786},
  url = {https://doi.org/10.1145/2503778.2503786},
  urldate = {2022-01-04},
  abstract = {Haskell's type system has outgrown its Hindley-Milner roots to the extent that it now stretches to the basics of dependently typed programming. In this paper, we collate and classify techniques for programming with dependent types in Haskell, and contribute some new ones. In particular, through extended examples---merge-sort and rectangular tilings---we show how to exploit Haskell's constraint solver as a theorem prover, delivering code which, as Agda programmers, we envy. We explore the compromises involved in simulating variations on the theme of the dependent function space in an attempt to help programmers put dependent types to work, and to inform the evolving language design both of Haskell and of dependently typed languages more broadly.},
  isbn = {978-1-4503-2383-3},
  keywords = {Dependent types,Type families},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\ICT3WS55\\Lindley and McBride - 2013 - Hasochism the pleasure and pain of dependently typed programming in Haskell.pdf}
}

@inproceedings{LohGeneric11,
  title = {Generic Programming with Indexed Functors},
  booktitle = {Proceedings of the Seventh {{ACM SIGPLAN}} Workshop on {{Generic}} Programming},
  author = {L{\"o}h, Andres and Magalh{\~a}es, Jos{\'e} Pedro},
  year = {2011},
  month = sep,
  series = {{{WGP}} '11},
  pages = {1--12},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2036918.2036920},
  url = {https://doi.org/10.1145/2036918.2036920},
  urldate = {2022-01-04},
  abstract = {Much has been said and done about generic programming approaches in strongly-typed functional languages such as Haskell and Agda. Different approaches use different techniques and are better or worse suited for certain uses, depending on design decisions such as generic view, universe size and complexity, etc. We present a simple and intuitive yet powerful approach to generic programming in Agda using indexed functors. We show a universe incorporating fixed points that supports composition, indexing, and isomorphisms, and generalizes a number of previous approaches to generic programming with fixed points. Our indexed functors come with a map operation which obeys the functor laws, and associated recursion morphisms. Albeit expressive, the universe remains simple enough to allow defining standard recursion schemes as well as decidable equality. As for type-indexed datatypes, we show how to compute the type of one-hole contexts and define the generic zipper.},
  isbn = {978-1-4503-0861-8},
  keywords = {agda,datatype-generic programming,dependently-typed programming,indexed functor},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\RRG3CBSH\\Löh and Magalhães - 2011 - Generic programming with indexed functors.pdf}
}

@article{luksicLocalAlgebraicEffect2020,
  title = {Local {{Algebraic Effect Theories}}},
  author = {Luk{\v s}i{\v c}, {\v Z}iga and Pretnar, Matija},
  year = {2020},
  journal = {Journal of Functional Programming},
  volume = {30},
  eprint = {2005.13654},
  eprinttype = {arxiv},
  pages = {e13},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796819000212},
  url = {http://arxiv.org/abs/2005.13654},
  urldate = {2022-02-02},
  abstract = {Algebraic effects are computational effects that can be described with a set of basic operations and equations between them. As many interesting effect handlers do not respect these equations, most approaches assume a trivial theory, sacrificing both reasoning power and safety. We present an alternative approach where the type system tracks equations that are observed in subparts of the program, yielding a sound and flexible logic, and paving a way for practical optimizations and reasoning tools.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\AFLG6GQI\\Lukšič and Pretnar - 2020 - Local Algebraic Effect Theories.pdf}
}

@article{MaillardDijkstra19,
  title = {Dijkstra Monads for All},
  author = {Maillard, Kenji and Ahman, Danel and Atkey, Robert and Mart{\'i}nez, Guido and Hri{\c t}cu, C{\u a}t{\u a}lin and Rivas, Exequiel and Tanter, {\'E}ric},
  year = {2019},
  month = jul,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {3},
  number = {ICFP},
  pages = {104:1--104:29},
  doi = {10.1145/3341708},
  url = {https://doi.org/10.1145/3341708},
  urldate = {2022-01-04},
  abstract = {This paper proposes a general semantic framework for verifying programs with arbitrary monadic side-effects using Dijkstra monads, which we define as monad-like structures indexed by a specification monad. We prove that any monad morphism between a computational monad and a specification monad gives rise to a Dijkstra monad, which provides great flexibility for obtaining Dijkstra monads tailored to the verification task at hand. We moreover show that a large variety of specification monads can be obtained by applying monad transformers to various base specification monads, including predicate transformers and Hoare-style pre- and postconditions. For defining correct monad transformers, we propose a language inspired by Moggi's monadic metalanguage that is parameterized by a dependent type theory. We also develop a notion of algebraic operations for Dijkstra monads, and start to investigate two ways of also accommodating effect handlers. We implement our framework in both Coq and F*, and illustrate that it supports a wide variety of verification styles for effects such as exceptions, nondeterminism, state, input-output, and general recursion.},
  keywords = {Dependent types,foundations,Monads,program verification,side-effects},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\NALJV4R2\\Maillard et al. - 2019 - Dijkstra monads for all.pdf}
}

@inproceedings{McBrideClowns08,
  title = {Clowns to the Left of Me, Jokers to the Right (Pearl): Dissecting Data Structures},
  shorttitle = {Clowns to the Left of Me, Jokers to the Right (Pearl)},
  booktitle = {Proceedings of the 35th Annual {{ACM SIGPLAN-SIGACT}} Symposium on {{Principles}} of Programming Languages},
  author = {McBride, Conor},
  year = {2008},
  month = jan,
  series = {{{POPL}} '08},
  pages = {287--295},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1328438.1328474},
  url = {https://doi.org/10.1145/1328438.1328474},
  urldate = {2022-01-04},
  abstract = {This paper introduces a small but useful generalisation to the 'derivative' operation on datatypes underlying Huet's notion of 'zipper', giving a concrete representation to one-hole contexts in data which is undergoing transformation. This operator, 'dissection', turns a container-like functor into a bifunctor representing a one-hole context in which elements to the left of the hole are distinguished in type from elements to its right. I present dissection here as a generic program, albeit for polynomial functors only. The notion is certainly applicable more widely, but here I prefer to concentrate on its diverse applications. For a start, map-like operations over the functor and fold-like operations over the recursive data structure it induces can be expressed by tail recursion alone. Further, the derivative is readily recovered from the dissection. Indeed, it is the dissection structure which delivers Huet's operations for navigating zippers. The original motivation for dissection was to define 'division', capturing the notion of leftmost hole, canonically distinguishing values with no elements from those with at least one. Division gives rise to an isomorphism corresponding to the remainder theorem in algebra. By way of a larger example, division and dissection are exploited to give a relatively efficient generic algorithm for abstracting all occurrences of one term from another in a first-order syntax. The source code for the paper is available online and compiles with recent extensions to the Glasgow Haskell Compiler.},
  isbn = {978-1-59593-689-9},
  keywords = {Data types,Differentiation,Dissection,Traversal,Zipper},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\7FPHGZXC\\McBride - 2008 - Clowns to the left of me, jokers to the right.pdf}
}

@misc{McBrideKleisli11,
  title = {Kleisli Arrows of Outrageous Fortune},
  author = {McBride, Conor},
  year = {2011},
  abstract = {When we program to interact with a turbulent world, we are to some extent at its mercy. To achieve safety, we must ensure that programs act in accordance with what is known about the state of the world, as determined dynamically. Is there any hope to enforce safety policies for dynamic interaction by static typing? This paper answers with a cautious `yes'. Monads provide a type discipline for effectful programming, mapping value types to computation types. If we index our types by data approximating the `state of the world', we refine our values to witnesses for some condition of the world. Ordinary monads for indexed types give a discipline for effectful programming contingent on state, modelling the whims of fortune in way that Atkey's indexed monads for ordinary types do not (Atkey, 2009). Arrows in the corresponding Kleisli category represent computations which a reach a given postcondition from a given precondition: their types are just specifications in a Hoare logic! By way of an elementary introduction to this approach, I present the example of a monad for interacting with a file handle which is either `open ' or `closed', constructed from a command interface specfied Hoare-style. An attempt to open a file results in a state which is statically unpredictable but dynamically detectable. Well typed programs behave accordingly in either case. Haskell's dependent type system, as exposed by the Strathclyde Haskell Enhancement preprocessor, provides a suitable basis for this simple experiment. 1},
  keywords = {Algebraic effects,Data types,Dependent types,Domain-specific languages},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\3DQJGVH9\\McBride - 2011 - Kleisli arrows of outrageous fortune.pdf}
}

@article{mcbrideOrnamentalAlgebrasAlgebraic2011,
  title = {Ornamental {{Algebras}}, {{Algebraic Ornaments}}},
  author = {McBride, Conor},
  year = {2011},
  pages = {24},
  abstract = {This paper re-examines the presentation of datatypes in dependently typed languages, addressing in particular the issue of what it means for one datatype to be in various ways more informative than another. Informal human observations like `lists are natural numbers with extra decoration' and `vectors are lists indexed by length' are expressed in a first class language of ornaments \textemdash presentations of fancy new types based on plain old ones \textemdash{} encompassing both decoration and, in the sense of Tim Freeman and Frank Pfenning (1991), refinement.},
  langid = {english},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\8WLY9VSW\\McBride - 2011 - Ornamental Algebras, Algebraic Ornaments.pdf}
}

@inproceedings{SchrijversMonad19,
  title = {Monad Transformers and Modular Algebraic Effects: What Binds Them Together},
  shorttitle = {Monad Transformers and Modular Algebraic Effects},
  booktitle = {Proceedings of the 12th {{ACM SIGPLAN International Symposium}} on {{Haskell}}},
  author = {Schrijvers, Tom and Pir{\'o}g, Maciej and Wu, Nicolas and Jaskelioff, Mauro},
  year = {2019},
  month = aug,
  series = {Haskell 2019},
  pages = {98--113},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3331545.3342595},
  url = {https://doi.org/10.1145/3331545.3342595},
  urldate = {2022-01-04},
  abstract = {For over two decades, monad transformers have been the main modular approach for expressing purely functional side-effects in Haskell. Yet, in recent years algebraic effects have emerged as an alternative whose popularity is growing. While the two approaches have been well-studied, there is still confusion about their relative merits and expressiveness, especially when it comes to their comparative modularity. This paper clarifies the connection between the two approaches\textemdash some of which is folklore\textemdash and spells out consequences that we believe should be better known. We characterise a class of algebraic effects that is modular, and show how these correspond to a specific class of monad transformers. In particular, we show that our modular algebraic effects gives rise to monad transformers. Moreover, every monad transformer for algebraic operations gives rise to a modular effect handler.},
  isbn = {978-1-4503-6813-1},
  keywords = {Algebraic effects,Handlers,Monad transformers,Monads},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\RNIUKCIS\\Schrijvers et al. - 2019 - Monad transformers and modular algebraic effects.pdf}
}

@incollection{SheeranDescribingCircuits90,
  title = {Describing and Reasoning about Circuits Using Relations},
  booktitle = {Theoretical {{Foundations}} of {{VLSI Design}}},
  author = {Sheeran, M.},
  editor = {Tucker, J. V. and McEvoy, K.},
  year = {1990},
  series = {Cambridge {{Tracts}} in {{Theoretical Computer Science}}},
  pages = {263--298},
  publisher = {{Cambridge University Press}},
  address = {{Cambridge}},
  doi = {10.1017/CBO9780511569838.009},
  url = {https://www.cambridge.org/core/books/theoretical-foundations-of-vlsi-design/describing-and-reasoning-about-circuits-using-relations/A3FE34786160BB4E8751F59135CE367B},
  urldate = {2022-02-28},
  abstract = {INTRODUCTIONOne of the natural ways to model circuit behaviour is to describe a circuit as a function from signals to signals. A signal is a stream of data values over time, that is, a function from integers to values. One can choose to name signals and to reason about their values. We have taken an alternative approach in our work on the design language {$\mu$}FP (Sheeran [1984]). We reason about circuits, that is functions from signals to signals, rather than about the signals themselves. We build circuit descriptions by `plugging together' smaller circuit descriptions using a carefully chosen set of combining forms. So, signals are first order functions, circuits are second order, and combining forms are third order.Each combining form maps one or more circuits to a single circuit. The combining forms were chosen to reflect the fact that circuits are essentially two-dimensional. So, they correspond to ways of laying down and wiring together circuit blocks. Each combining form has both a behavioural and a pictorial interpretation. Because they obey useful mathematical laws, we can use program transformation in the development of circuits. An initial obviously correct circuit can be transformed into one with the same behaviour, but a more acceptable layout. It has been shown that this functional approach is particularly useful in the design of regular array architectures (Sheeran [1985, 1986], Luk \&amp; Jones [1988a]).However, sometimes a relational description of a circuit is more appropriate than a functional one.},
  isbn = {978-0-521-54565-5}
}

@article{SheeranHardwareFP05,
  title = {Hardware {{Design}} and {{Functional Programming}}: A {{Perfect Match}} (Extended Version)},
  shorttitle = {Hardware {{Design}} and {{Functional Programming}}},
  author = {Sheeran, Mary},
  year = {2005},
  journal = {Journal of Universal Computer Science, Special Issue on Brazilian Symposium on Programming Languages},
  volume = {11},
  number = {7},
  url = {https://research.chalmers.se/en/publication/6187},
  urldate = {2022-01-04},
  langid = {english},
  keywords = {Hardware},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\ZJQ8UFFD\\Sheeran - 2005 - Hardware Design and Functional Programming a Perfect Match.pdf}
}

@phdthesis{SinghHWAnalysis91,
  title = {Analysis of {{Hardware Descriptions}}},
  author = {Singh, Satnam},
  year = {1991},
  address = {{Glasgow}},
  url = {https://theses.gla.ac.uk/78311/},
  urldate = {2022-01-04},
  abstract = {The design process for integrated circuits requires a lot of analysis of circuit descriptions. An important class of analyses determines how easy it will be to determine if a physical component suffers from any manufacturing errors. As circuit complexities grow rapidly, the problem of testing circuits also becomes increasingly difficult. This thesis explores the potential for analysing a recent high level hardware description language called Ruby. In particular, we are interested in performing testability analyses of Ruby circuit descriptions. Ruby is ammenable to algebraic manipulation, so we have sought transformations that improve testability while preserving behaviour. The analysis of Ruby descriptions is performed by adapting a technique called abstract interpretation. This has been used successfully to analyse functional programs. This technique is most applicable where the analysis to be captured operates over structures isomorphic to the structure of the circuit. Many digital systems analysis tools require the circuit description to be given in some special form. This can lead to inconsistency between representations, and involves additional work converting between representations. We propose using the original description medium, in this case Ruby, for performing analyses. A related technique, called non-standard interpretation, is shown to be very useful for capturing many circuit analyses. An implementation of a system that performs non-standard interpretation forms the central part of the work. This allows Ruby descriptions to be analysed using alternative interpretations such test pattern generation and circuit layout interpretations. This system follows a similar approach to Boute's system semantics work and O'Donnell's work on Hydra. However, we have allowed a larger class of interpretations to be captured and offer a richer description language. The implementation presented here is constructed to allow a large degree of code sharing between different analyses. Several analyses have been implemented including simulation, test pattern generation and circuit layout. Non-standard interpretation provides a good framework for implementing these analyses. A general model for making non-standard interpretations is presented. Combining forms that combine two interpretations to produce a new interpretation are also introduced. This allows complex circuit analyses to be decomposed in a modular manner into smaller circuit analyses which can be built independently.},
  langid = {english},
  school = {University of Glasgow},
  keywords = {Hardware,Non-standard interpretation,Relational programming,Ruby,Testing},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\29K48LXC\\Singh - 1991 - Analysis of Hardware Descriptions.pdf}
}

@article{SvenssonDSLExploration14,
  title = {Design {{Exploration}} through {{Code-generating DSLs}}: {{High-level DSLs}} for Low-Level Programming},
  shorttitle = {Design {{Exploration}} through {{Code-generating DSLs}}},
  author = {Svensson, Bo Joel and Sheeran, Mary and Newton, Ryan},
  year = {2014},
  month = apr,
  journal = {Queue},
  volume = {12},
  number = {4},
  pages = {40--52},
  issn = {1542-7730},
  doi = {10.1145/2611429.2626374},
  url = {https://doi.org/10.1145/2611429.2626374},
  urldate = {2022-01-04},
  abstract = {DSLs (domain-specific languages) make programs shorter and easier to write. They can be stand-alone - for example, LaTeX, Makefiles, and SQL - or they can be embedded in a host language. You might think that DSLs embedded in high-level languages would be abstract or mathematically oriented, far from the nitty-gritty of low-level programming. This is not the case. This article demonstrates how high-level EDSLs (embedded DSLs) really can ease low-level programming. There is no contradiction.},
  keywords = {Domain-specific languages,GPU},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\EYP347RI\\Svensson et al. - 2014 - Design Exploration through Code-generating DSLs.pdf}
}

@article{SwierstraDTC08,
  title = {Data Types \`a La Carte},
  author = {Swierstra, Wouter},
  year = {2008},
  month = jul,
  journal = {Journal of Functional Programming},
  volume = {18},
  number = {4},
  pages = {423--436},
  issn = {0956-7968},
  doi = {10.1017/S0956796808006758},
  url = {https://doi.org/10.1017/S0956796808006758},
  urldate = {2022-01-06},
  abstract = {This paper describes a technique for assembling both data types and functions from isolated individual components. We also explore how the same technology can be used to combine free monads and, as a result, structure Haskell's monolithic IO monad.},
  keywords = {Algebraic effects,Data types,Monads},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\AAXHL6WH\\Swierstra - 2008 - Data types à la carte.pdf}
}

@inproceedings{vandenBergLatent21,
  title = {Latent {{Effects}} for {{Reusable Language Components}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {{van den Berg}, Birthe and Schrijvers, Tom and Poulsen, Casper Bach and Wu, Nicolas},
  editor = {Oh, Hakjoo},
  year = {2021},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {182--201},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-89051-3_11},
  abstract = {The development of programming languages can be quite complicated and costly. Hence, much effort has been devoted to the modular definition of language features that can be reused in various combinations to define new languages and experiment with their semantics. A notable outcome of these efforts is the algebra-based ``datatypes \`a la carte'' (DTC) approach. When combined with algebraic effects, DTC can model a wide range of common language features. Unfortunately, the current state of the art does not cover modular definitions of advanced control-flow mechanisms that defer execution to an appropriate point, such as call-by-name and call-by-need evaluation, as well as (multi-)staging.This paper defines latent effects, a generic class of such control-flow mechanisms. We demonstrate how function abstractions, lazy computations and a MetaML-like staging can all be expressed in a modular fashion using latent effects, and how they can be combined in various ways to obtain complex semantics. We provide a full Haskell implementation of our effects and handlers with a range of examples.},
  isbn = {978-3-030-89051-3},
  langid = {english},
  keywords = {Algebraic effects,Effect handlers,Modularity,Monads,Staging},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\AWK4HXTQ\\van den Berg et al. - 2021 - Latent Effects for Reusable Language Components.pdf}
}

@inproceedings{WadlerFree89,
  title = {Theorems for Free!},
  booktitle = {Proceedings of the Fourth International Conference on {{Functional}} Programming Languages and Computer Architecture},
  author = {Wadler, Philip},
  year = {1989},
  month = nov,
  series = {{{FPCA}} '89},
  pages = {347--359},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/99370.99404},
  url = {https://doi.org/10.1145/99370.99404},
  urldate = {2022-01-04},
  abstract = {From the type of a polymorphic function we can derive a theorem that it satisfies. Every function of the same type satisfies the same theorem. This provides a free source of useful theorems, courtesy of Reynolds' abstraction theorem for the polymorphic lambda calculus.},
  isbn = {978-0-89791-328-7},
  keywords = {Lambda calculus,Polymorphism,Type theory},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\5VT3LSHA\\Wadler - 1989 - Theorems for free!.pdf}
}

@mastersthesis{WangCoby21,
  title = {Coby - {{A Coq Library}} for {{Ruby Verification}}},
  author = {Wang, Qianzhou},
  year = {2021},
  month = sep,
  address = {{London}},
  abstract = {We report the design and implementation of a new Coq library for verifying Ruby designs called Coby, since it involves combining Coq and Ruby. Ruby is a VLSI design language for describing the structure and behaviour of sequential and combinational circuits. We model Ruby relations as functions in the Coq theorem prover, a formal language to reason about mathematical expressions. Coby benefits from Coq's automated type checking and supports transformational rewrite to convert pen-and-paper proof into computer-aided proof. Coby also provides a Ruby simulator, supporting numerical and symbolic simulation for both timeless and sequential circuits. Three examples with increasing difficulty are used to showcase the power of the new system. We evaluate Coby by a case study: an optimisation of in-circuit temporal monitor. We compare Coby with an existing Ruby verification framework, RubyZF.},
  school = {Imperial College London},
  file = {C\:\\Users\\Omar\\Zotero\\storage\\MWTURUSR\\Wang - 2021 - Coby - A Coq Library for Ruby Verification.pdf}
}


